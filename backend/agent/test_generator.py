"""
1INTERPRETER Test Generator
AI-powered test generation and automation
"""
import os
import ast
import time
from pathlib import Path
from typing import Dict, List, Any, Optional

import sys
from pathlib import Path

# Add backend to path for imports
backend_path = Path(__file__).parent.parent
sys.path.insert(0, str(backend_path))

from llm.llm_wrapper import get_llm

class TestGenerator:
    """AI-powered test generation for Python projects"""
    
    def __init__(self):
        self.llm = get_llm()
        self.tests_dir = Path("generated_tests")
        self.tests_dir.mkdir(exist_ok=True)
    
    def generate_tests(self, project_path: str = ".") -> Dict[str, Any]:
        """Generate comprehensive test suite for project"""
        
        start_time = time.time()
        project_path = Path(project_path)
        
        try:
            # Analyze code structure
            code_analysis = self._analyze_code_structure(project_path)
            
            # Generate AI-powered tests
            test_files = self._generate_test_files(code_analysis)
            
            # Create test configuration
            test_config = self._generate_test_config()
            
            execution_time = time.time() - start_time
            
            summary = f"""✅ Test Suite Generated:
📁 Project: {project_path.name}
🧪 Test Files: {len(test_files)}
🔍 Functions Covered: {code_analysis.get('function_count', 0)}
⏱️ Generation Time: {execution_time:.2f}s
📄 Config: pytest.ini created"""
            
            return {
                "success": True,
                "summary": summary,
                "test_files": test_files,
                "config_files": [str(self.tests_dir / "pytest.ini")],
                "coverage_report": "tests/coverage_report.html",
                "execution_time": execution_time
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "summary": f"❌ Test generation failed: {str(e)}"
            }
    
    def _analyze_code_structure(self, project_path: Path) -> Dict[str, Any]:
        """Analyze code to understand what needs testing"""
        
        functions = []
        classes = []
        
        for py_file in project_path.rglob("*.py"):
            if "test" in py_file.name:
                continue
                
            try:
                content = py_file.read_text(encoding='utf-8')
                tree = ast.parse(content)
                
                for node in ast.walk(tree):
                    if isinstance(node, ast.FunctionDef) and not node.name.startswith('_'):
                        functions.append({
                            "file": str(py_file),
                            "name": node.name,
                            "line": node.lineno,
                            "args": [arg.arg for arg in node.args.args]
                        })
                    elif isinstance(node, ast.ClassDef):
                        classes.append({
                            "file": str(py_file),
                            "name": node.name,
                            "line": node.lineno
                        })
            except:
                continue
        
        return {
            "functions": functions,
            "classes": classes,
            "function_count": len(functions),
            "class_count": len(classes)
        }
    
    def _generate_test_files(self, code_analysis: Dict[str, Any]) -> List[str]:
        """Generate test files using AI"""
        
        test_files = []
        
        # Group functions by file for better test organization
        files_to_test = {}
        for func in code_analysis["functions"]:
            file_path = func["file"]
            if file_path not in files_to_test:
                files_to_test[file_path] = []
            files_to_test[file_path].append(func)
        
        for file_path, functions in files_to_test.items():
            try:
                test_content = self._generate_test_content(file_path, functions)
                test_file_name = f"test_{Path(file_path).stem}.py"
                test_file_path = self.tests_dir / test_file_name
                
                with open(test_file_path, 'w') as f:
                    f.write(test_content)
                
                test_files.append(str(test_file_path))
                
            except Exception as e:
                print(f"Failed to generate tests for {file_path}: {e}")
        
        return test_files
    
    def _generate_test_content(self, file_path: str, functions: List[Dict]) -> str:
        """Generate test content for a specific file"""
        
        module_name = Path(file_path).stem
        
        test_template = f'''"""
Generated tests for {module_name}
Auto-generated by 1INTERPRETER Test Generator
"""
import pytest
import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from {module_name} import *
except ImportError as e:
    print(f"Could not import {module_name}: {{e}}")

'''
        
        # Generate tests for each function
        for func in functions:
            test_template += self._generate_function_tests(func)
        
        # Add integration tests
        test_template += f'''

class TestIntegration:
    """Integration tests for {module_name}"""
    
    def test_module_imports(self):
        """Test that the module imports correctly"""
        try:
            import {module_name}
            assert True
        except ImportError:
            pytest.fail(f"Could not import {module_name}")
    
    def test_basic_functionality(self):
        """Test basic module functionality"""
        # Add integration test logic here
        assert True

if __name__ == "__main__":
    pytest.main([__file__])
'''
        
        return test_template
    
    def _generate_function_tests(self, func: Dict) -> str:
        """Generate test cases for a specific function"""
        
        func_name = func["name"]
        func_args = func.get("args", [])
        
        test_code = f'''

class Test{func_name.title()}:
    """Tests for {func_name} function"""
    
    def test_{func_name}_exists(self):
        """Test that {func_name} function exists"""
        assert callable({func_name})
    
    def test_{func_name}_basic_case(self):
        """Test {func_name} with basic inputs"""
        # TODO: Add specific test cases based on function logic
        try:
            result = {func_name}({self._generate_mock_args(func_args)})
            assert result is not None
        except Exception as e:
            pytest.fail(f"Function {func_name} failed with basic inputs: {{e}}")
    
    def test_{func_name}_edge_cases(self):
        """Test {func_name} with edge cases"""
        # TODO: Add edge case testing
        # Test with None, empty values, boundary conditions
        pass
    
    def test_{func_name}_error_handling(self):
        """Test {func_name} error handling"""
        # TODO: Test invalid inputs and error conditions
        pass
'''
        
        return test_code
    
    def _generate_mock_args(self, args: List[str]) -> str:
        """Generate mock arguments for function testing"""
        if not args:
            return ""
        
        mock_values = []
        for arg in args[:3]:  # Limit to first 3 args
            if arg == "self":
                continue
            mock_values.append(f'"{arg}_test"')
        
        return ", ".join(mock_values)
    
    def _generate_test_config(self) -> str:
        """Generate pytest configuration"""
        
        config_content = '''[tool:pytest]
testpaths = generated_tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    --verbose
    --tb=short
    --cov=.
    --cov-report=html
    --cov-report=term-missing
markers =
    slow: marks tests as slow
    integration: marks tests as integration tests
    unit: marks tests as unit tests
'''
        
        config_file = self.tests_dir / "pytest.ini"
        with open(config_file, 'w') as f:
            f.write(config_content)
        
        return str(config_file)

if __name__ == "__main__":
    generator = TestGenerator()
    result = generator.generate_tests()
    print(result["summary"])
